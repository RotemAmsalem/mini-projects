from imageio import imread
from skimage.color import rgb2gray
import numpy as np
import scipy.ndimage
import scipy.signal
import matplotlib.pyplot as plt
import os


def read_image(filename, representation):
    """
    this function reads an image file and converts it into a given representation (1 for
    grayscale representation and 2 for RGB representation).
    :param filename: the image file name
    :param representation: the representation the function converts the image to
    :return: the image at the given representation (1-grayscale, 2-RGB)
    """
    im = imread(filename).astype(np.float64)
    if representation == 1:
        im_g = rgb2gray(im)
        return im_g.astype(np.float64)
    elif representation == 2:
        im /= 255
        return im.astype(np.float64)
    else:
        print("Unexpected action")


def gausian_kernel(size):
    """
    this function computes the 2D gaussian kernel
    :param size: the size of the gaussian kernel in each dimension (an odd integer)
    :return: vector of filter and 2D gaussian kernel
    """
    mat = np.array([1, 1])
    row = np.array([1, 1])
    for i in range(size - 2):
        row = scipy.signal.convolve(row, mat)
    col = row.reshape(1, size)
    conv_mat = scipy.signal.convolve2d(row.reshape(size,1), col).astype(np.float64)
    sum = conv_mat.sum()
    g = (1 / sum) * conv_mat
    return g, col


def reduce(im, filter_vec):
    """
    this function blur the image and then sub-sample it
    :param im: a grayscale image with double values in [0, 1]
    :param filter_vec: a row vector of shape (1, filter_size) used for the pyramid construction
    :return: the reduced image
    """
    filter_mat = scipy.signal.convolve2d(filter_vec, filter_vec.T).astype(np.float64)
    new_im = scipy.ndimage.filters.convolve(im, filter_mat)
    new_im = scipy.ndimage.filters.convolve(new_im, filter_mat.T).astype(np.float64)
    return new_im[::2, ::2]


def build_gaussian_pyramid(im, max_levels, filter_size):
    """
    this function construct a Gaussian pyramid of a given image.
    :param im: a grayscale image with double values in [0, 1]
    :param max_levels: the maximal number of levels1 in the resulting pyramid
    :param filter_size: the size of the Gaussian filter (an odd scalar that represents a squared
    filter) to be used in constructing the pyramid filter
    :return: pyr - the resulting pyramid pyr as a standard python array with maximum length of
    max_levels, where each element of the array is a grayscale image and
    filter_vec - which is row vector of shape (1, filter_size) used for the pyramid construction
    """
    pyr = [im]
    filter_vec = gausian_kernel(filter_size)
    for i in range(max_levels - 1):
        im = reduce(im, filter_vec[0])
        pyr.append(im)
    return pyr, filter_vec[1]


def expand(im, filter_vec):
    """
    this function do zero-padding and blur the image
    :param im: a grayscale image with double values in [0, 1]
    :param filter_vec: a row vector of shape (1, filter_size) used for the pyramid construction
    :return: the expanded image
    """
    new_im = np.zeros([len(im) * 2, len(im[0]) * 2])
    new_im[::2, ::2] = im
    filter_mat = scipy.signal.convolve2d(filter_vec, filter_vec.T).astype(np.float64)
    new_im = scipy.ndimage.filters.convolve(new_im, filter_mat)
    new_im = scipy.ndimage.filters.convolve(new_im, filter_mat.T).astype(np.float64)
    return new_im


def build_laplacian_pyramid(im, max_levels, filter_size):
    """
    this function construct a Laplacian pyramid of a given image.
    :param im: a grayscale image with double values in [0, 1]
    :param max_levels: the maximal number of levels in the resulting pyramid
    :param filter_size: the size of the Gaussian filter (an odd scalar that represents a squared
    filter) to be used in constructing the pyramid filter
    :return: pyr - the resulting pyramid pyr as a standard python array with maximum length of
    max_levels, where each element of the array is a grayscale image and
    filter_vec - which is row vector of shape (1, filter_size) used for the pyramid construction
    """
    pyr = []
    filter_vec = gausian_kernel(filter_size)
    gaus_pyr = build_gaussian_pyramid(im, max_levels, filter_size)[0]
    for i in range(max_levels - 1):
        pyr.append(gaus_pyr[i] - expand(gaus_pyr[i+1], 2 * filter_vec[1]))
    pyr.append(gaus_pyr[max_levels - 1])
    return pyr, filter_vec[1]


def laplacian_to_image(lpyr, filter_vec, coeff):
    """
    this function reconstruct an image from its Laplacian Pyramid
    :param lpyr: Laplacian pyramid that is generated by build_laplacian_pyramid function
    :param filter_vec: filter that is generated by build_laplacian_pyramid function
    :param coeff: a python list. The list length is the same as the number of levels in the
    pyramid lpyr
    :return: a grayscale image (the original if all values at coeff are 1 but when some values are
    different than 1 we will get filtering effects.)
    """
    im = lpyr[len(lpyr) - 1] * coeff[len(lpyr) - 1]
    for i in range(len(lpyr) - 2, -1, -1):
        lpyr[i] = lpyr[i]*coeff[i]
        im = expand(im, 2 * filter_vec) + lpyr[i]
    img = np.array(im)
    return img.astype(np.float64)


def render_pyramid(pyr, levels):
    """
    :param pyr: a Gaussian or Laplacian pyramid as defined above.
    :param levels: the number of levels
    :return: a single black image in which the pyramid levels of the given pyramid pyr are
    stacked horizontally
    """
    length = 0
    for i in range(len(pyr)):
        pyr[i] = pyr[i]-np.amin(pyr[i])
        pyr[i] = pyr[i]/np.amax(pyr[i])
    for i in range(levels):
        length += len(pyr[i])
    black_im = np.zeros([len(pyr[0]), length])
    start = 0
    count = 0
    for i in range(levels):
        count += len(pyr[i])
        black_im[:len(pyr[i]), start:count] = pyr[i]
        start = count
    return black_im


def display_pyramid(pyr, levels):
    """
    this function use render_pyramid to internally render and then display the stacked pyramid image
    :param pyr: a Gaussian or Laplacian pyramid as defined above.
    :param levels: the number of levels
    :return:
    """
    black_im = render_pyramid(pyr, levels)
    plt.imshow(black_im, cmap='gray')
    plt.show()


def pyramid_blending(im1, im2, mask, max_levels, filter_size_im, filter_size_mask):
    """

    :param im1: first input grayscale images to be blended
    :param im2: second input grayscale images to be blended
    :param mask: a boolean mask containing True and False representing which parts of im1 and im2
    should appear in the resulting im_blend. Note that a value of True corresponds to 1,
    and False corresponds to 0
    :param max_levels: the number of levels at the Gaussian and Laplacian pyramids
    :param filter_size_im: the size of the Gaussian filter which defining the filter used in the
    construction of the Laplacian pyramids of im1 and im2.
    :param filter_size_mask: the size of the Gaussian filter which defining the filter used in
    the construction of the Gaussian pyramid of mask.
    :return: blended image
    """
    l1, filter_vec = build_laplacian_pyramid(im1, max_levels, filter_size_im)
    l2 = build_laplacian_pyramid(im2, max_levels, filter_size_im)[0]
    g_m = build_gaussian_pyramid(mask.astype(np.double), max_levels, filter_size_mask)[0]
    l_out = []
    coeff = [1]*max_levels
    for k in range(max_levels):
        l_out.append(np.multiply(g_m[k], l1[k]) + np.multiply((1 - g_m[k]), l2[k]))
    im_blend = laplacian_to_image(l_out, filter_vec, coeff)
    return np.clip(im_blend, 0, 1)


def relpath(filename):
    """
    with this function I use relative paths together when loading my own images
    :param filename: the name of the file
    :return: the path of the file
    """
    return os.path.join(os.path.dirname(__file__), filename)


def blending_example1():
    """
    This function will be performing pyramid blending on set of image pair and mask.
    this function display the two input images, the mask, and the resulting blended image in a
    single figure, before returning these objects.
    :return: it returns the two images (im1 and im2), the mask (mask) and the resulting blended
    image (im_blend).
    """
    plt.figure()
    im1 = read_image(relpath('jordan.jpg'), 2)
    plt.subplot(221)
    plt.imshow(im1)
    im2 = read_image(relpath('ball.jpg'), 2)
    plt.subplot(222)
    plt.imshow(im2)
    mask = read_image(relpath('mask1.jpg'), 1)
    mask[mask < 0.5] = 0
    mask[mask >= 0.5] = 1
    plt.subplot(223)
    plt.imshow(mask, cmap='gray')
    im_blend = np.zeros([len(im1), len(im1[0]), 3])
    for i in range(3):
        im_blend[..., i] = pyramid_blending(im1[..., i], im2[..., i], mask, 1, 3, 3)
    plt.subplot(224)
    plt.imshow(im_blend)
    plt.show()
    return im1, im2, mask.astype(np.bool), im_blend


def blending_example2():
    """
    This function will be performing pyramid blending on another set of image pair and mask.
    this function display the two input images, the mask, and the resulting blended image in a
    single figure, before returning these objects.
    :return: it returns the two images (im1 and im2), the mask (mask) and the resulting blended
    image (im_blend).
    """
    plt.figure()
    im1 = read_image(relpath('garden.jpg'), 2)
    plt.subplot(221)
    plt.imshow(im1)
    im2 = read_image(relpath('sea.jpg'), 2)
    plt.subplot(222)
    plt.imshow(im2)
    mask = read_image(relpath('mask2.jpg'), 1)
    mask[mask < 0.5] = 0
    mask[mask >= 0.5] = 1
    plt.subplot(223)
    plt.imshow(mask, cmap='gray')
    im_blend = np.zeros([len(im1), len(im1[0]), 3])
    for i in range(3):
        im_blend[..., i] = pyramid_blending(im1[..., i], im2[..., i], mask, 1, 3, 3)
        im_blend[..., i] = pyramid_blending(im1[..., i], im2[..., i], mask, 1, 3, 3)
    plt.subplot(224)
    plt.imshow(im_blend)
    plt.show()
    return im1, im2, mask.astype(np.bool), im_blend
